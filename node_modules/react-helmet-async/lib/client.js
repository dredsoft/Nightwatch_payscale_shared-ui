'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.requestAnimationFrame = undefined;

var _constants = require('./constants');

var _utils = require('./utils');

var rafPolyfill = function () {
  var clock = Date.now();

  return function (callback) {
    var currentTime = Date.now();

    if (currentTime - clock > 16) {
      clock = currentTime;
      callback(currentTime);
    } else {
      setTimeout(function () {
        rafPolyfill(callback);
      }, 0);
    }
  };
}();

var updateTags = function updateTags(type, tags) {
  var headElement = document.head || document.querySelector(_constants.TAG_NAMES.HEAD);
  var tagNodes = headElement.querySelectorAll(type + '[' + _constants.HELMET_ATTRIBUTE + ']');
  var oldTags = [].slice.call(tagNodes);
  var newTags = [];
  var indexToDelete = void 0;

  if (tags && tags.length) {
    tags.forEach(function (tag) {
      var newElement = document.createElement(type);

      // eslint-disable-next-line
      for (var attribute in tag) {
        if (Object.prototype.hasOwnProperty.call(tag, attribute)) {
          if (attribute === _constants.TAG_PROPERTIES.INNER_HTML) {
            newElement.innerHTML = tag.innerHTML;
          } else if (attribute === _constants.TAG_PROPERTIES.CSS_TEXT) {
            if (newElement.styleSheet) {
              newElement.styleSheet.cssText = tag.cssText;
            } else {
              newElement.appendChild(document.createTextNode(tag.cssText));
            }
          } else {
            var value = typeof tag[attribute] === 'undefined' ? '' : tag[attribute];
            newElement.setAttribute(attribute, value);
          }
        }
      }

      newElement.setAttribute(_constants.HELMET_ATTRIBUTE, 'true');

      // Remove a duplicate tag from domTagstoRemove, so it isn't cleared.
      if (oldTags.some(function (existingTag, index) {
        indexToDelete = index;
        return newElement.isEqualNode(existingTag);
      })) {
        oldTags.splice(indexToDelete, 1);
      } else {
        newTags.push(newElement);
      }
    });
  }

  oldTags.forEach(function (tag) {
    return tag.parentNode.removeChild(tag);
  });
  newTags.forEach(function (tag) {
    return headElement.appendChild(tag);
  });

  return {
    oldTags: oldTags,
    newTags: newTags
  };
};

var updateAttributes = function updateAttributes(tagName, attributes) {
  var elementTag = document.getElementsByTagName(tagName)[0];

  if (!elementTag) {
    return;
  }

  var helmetAttributeString = elementTag.getAttribute(_constants.HELMET_ATTRIBUTE);
  var helmetAttributes = helmetAttributeString ? helmetAttributeString.split(',') : [];
  var attributesToRemove = [].concat(helmetAttributes);
  var attributeKeys = Object.keys(attributes);

  for (var i = 0; i < attributeKeys.length; i += 1) {
    var attribute = attributeKeys[i];
    var value = attributes[attribute] || '';

    if (elementTag.getAttribute(attribute) !== value) {
      elementTag.setAttribute(attribute, value);
    }

    if (helmetAttributes.indexOf(attribute) === -1) {
      helmetAttributes.push(attribute);
    }

    var indexToSave = attributesToRemove.indexOf(attribute);
    if (indexToSave !== -1) {
      attributesToRemove.splice(indexToSave, 1);
    }
  }

  for (var _i = attributesToRemove.length - 1; _i >= 0; _i -= 1) {
    elementTag.removeAttribute(attributesToRemove[_i]);
  }

  if (helmetAttributes.length === attributesToRemove.length) {
    elementTag.removeAttribute(_constants.HELMET_ATTRIBUTE);
  } else if (elementTag.getAttribute(_constants.HELMET_ATTRIBUTE) !== attributeKeys.join(',')) {
    elementTag.setAttribute(_constants.HELMET_ATTRIBUTE, attributeKeys.join(','));
  }
};

var updateTitle = function updateTitle(title, attributes) {
  if (typeof title !== 'undefined' && document.title !== title) {
    document.title = (0, _utils.flattenArray)(title);
  }

  updateAttributes(_constants.TAG_NAMES.TITLE, attributes);
};

var commitTagChanges = function commitTagChanges(newState, cb) {
  var baseTag = newState.baseTag,
      bodyAttributes = newState.bodyAttributes,
      htmlAttributes = newState.htmlAttributes,
      linkTags = newState.linkTags,
      metaTags = newState.metaTags,
      noscriptTags = newState.noscriptTags,
      onChangeClientState = newState.onChangeClientState,
      scriptTags = newState.scriptTags,
      styleTags = newState.styleTags,
      title = newState.title,
      titleAttributes = newState.titleAttributes;

  updateAttributes(_constants.TAG_NAMES.BODY, bodyAttributes);
  updateAttributes(_constants.TAG_NAMES.HTML, htmlAttributes);

  updateTitle(title, titleAttributes);

  var tagUpdates = {
    baseTag: updateTags(_constants.TAG_NAMES.BASE, baseTag),
    linkTags: updateTags(_constants.TAG_NAMES.LINK, linkTags),
    metaTags: updateTags(_constants.TAG_NAMES.META, metaTags),
    noscriptTags: updateTags(_constants.TAG_NAMES.NOSCRIPT, noscriptTags),
    scriptTags: updateTags(_constants.TAG_NAMES.SCRIPT, scriptTags),
    styleTags: updateTags(_constants.TAG_NAMES.STYLE, styleTags)
  };

  var addedTags = {};
  var removedTags = {};

  Object.keys(tagUpdates).forEach(function (tagType) {
    var _tagUpdates$tagType = tagUpdates[tagType],
        newTags = _tagUpdates$tagType.newTags,
        oldTags = _tagUpdates$tagType.oldTags;


    if (newTags.length) {
      addedTags[tagType] = newTags;
    }
    if (oldTags.length) {
      removedTags[tagType] = tagUpdates[tagType].oldTags;
    }
  });

  if (cb) {
    cb();
  }

  onChangeClientState(newState, addedTags, removedTags);
};

var cafPolyfill = function cafPolyfill(id) {
  return clearTimeout(id);
};

var requestAnimationFrame = exports.requestAnimationFrame = typeof window !== 'undefined' ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || rafPolyfill : global.requestAnimationFrame || rafPolyfill;

var cancelAnimationFrame = typeof window !== 'undefined' ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || cafPolyfill : global.cancelAnimationFrame || cafPolyfill;

// eslint-disable-next-line
var _helmetCallback = null;

var handleStateChangeOnClient = function handleStateChangeOnClient(newState) {
  if (_helmetCallback) {
    cancelAnimationFrame(_helmetCallback);
  }

  if (newState.defer) {
    _helmetCallback = requestAnimationFrame(function () {
      commitTagChanges(newState, function () {
        _helmetCallback = null;
      });
    });
  } else {
    commitTagChanges(newState);
    _helmetCallback = null;
  }
};

exports.default = handleStateChangeOnClient;