'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _constants = require('./constants');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var SELF_CLOSING_TAGS = [_constants.TAG_NAMES.NOSCRIPT, _constants.TAG_NAMES.SCRIPT, _constants.TAG_NAMES.STYLE];

var encodeSpecialCharacters = function encodeSpecialCharacters(str) {
  var encode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (encode === false) {
    return String(str);
  }

  return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;');
};

var generateElementAttributesAsString = function generateElementAttributesAsString(attributes) {
  return Object.keys(attributes).reduce(function (str, key) {
    var attr = typeof attributes[key] !== 'undefined' ? key + '="' + attributes[key] + '"' : '' + key;
    return str ? str + ' ' + attr : attr;
  }, '');
};

var generateTitleAsString = function generateTitleAsString(type, title, attributes, encode) {
  var attributeString = generateElementAttributesAsString(attributes);
  var flattenedTitle = (0, _utils.flattenArray)(title);
  return attributeString ? '<' + type + ' ' + _constants.HELMET_ATTRIBUTE + '="true" ' + attributeString + '>' + encodeSpecialCharacters(flattenedTitle, encode) + '</' + type + '>' : '<' + type + ' ' + _constants.HELMET_ATTRIBUTE + '="true">' + encodeSpecialCharacters(flattenedTitle, encode) + '</' + type + '>';
};

var generateTagsAsString = function generateTagsAsString(type, tags, encode) {
  return tags.reduce(function (str, tag) {
    var attributeHtml = Object.keys(tag).filter(function (attribute) {
      return !(attribute === _constants.TAG_PROPERTIES.INNER_HTML || attribute === _constants.TAG_PROPERTIES.CSS_TEXT);
    }).reduce(function (string, attribute) {
      var attr = typeof tag[attribute] === 'undefined' ? attribute : attribute + '="' + encodeSpecialCharacters(tag[attribute], encode) + '"';
      return string ? string + ' ' + attr : attr;
    }, '');

    var tagContent = tag.innerHTML || tag.cssText || '';

    var isSelfClosing = SELF_CLOSING_TAGS.indexOf(type) === -1;

    return str + '<' + type + ' ' + _constants.HELMET_ATTRIBUTE + '="true" ' + attributeHtml + (isSelfClosing ? '/>' : '>' + tagContent + '</' + type + '>');
  }, '');
};

var convertElementAttributesToReactProps = function convertElementAttributesToReactProps(attributes) {
  var initProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return Object.keys(attributes).reduce(function (obj, key) {
    obj[_constants.REACT_TAG_MAP[key] || key] = attributes[key];
    return obj;
  }, initProps);
};

var generateTitleAsReactComponent = function generateTitleAsReactComponent(type, title, attributes) {
  // assigning into an array to define toString function on it
  var initProps = _defineProperty({
    key: title
  }, _constants.HELMET_ATTRIBUTE, true);
  var props = convertElementAttributesToReactProps(attributes, initProps);

  return [_react2.default.createElement(_constants.TAG_NAMES.TITLE, props, title)];
};

var generateTagsAsReactComponent = function generateTagsAsReactComponent(type, tags) {
  return tags.map(function (tag, i) {
    var mappedTag = _defineProperty({
      key: i
    }, _constants.HELMET_ATTRIBUTE, true);

    Object.keys(tag).forEach(function (attribute) {
      var mappedAttribute = _constants.REACT_TAG_MAP[attribute] || attribute;

      if (mappedAttribute === _constants.TAG_PROPERTIES.INNER_HTML || mappedAttribute === _constants.TAG_PROPERTIES.CSS_TEXT) {
        var content = tag.innerHTML || tag.cssText;
        mappedTag.dangerouslySetInnerHTML = { __html: content };
      } else {
        mappedTag[mappedAttribute] = tag[attribute];
      }
    });

    return _react2.default.createElement(type, mappedTag);
  });
};

var getMethodsForTag = function getMethodsForTag(type, tags, encode) {
  switch (type) {
    case _constants.TAG_NAMES.TITLE:
      return {
        toComponent: function toComponent() {
          return generateTitleAsReactComponent(type, tags.title, tags.titleAttributes, encode);
        },
        toString: function toString() {
          return generateTitleAsString(type, tags.title, tags.titleAttributes, encode);
        }
      };
    case _constants.ATTRIBUTE_NAMES.BODY:
    case _constants.ATTRIBUTE_NAMES.HTML:
      return {
        toComponent: function toComponent() {
          return convertElementAttributesToReactProps(tags);
        },
        toString: function toString() {
          return generateElementAttributesAsString(tags);
        }
      };
    default:
      return {
        toComponent: function toComponent() {
          return generateTagsAsReactComponent(type, tags);
        },
        toString: function toString() {
          return generateTagsAsString(type, tags, encode);
        }
      };
  }
};

var mapStateOnServer = function mapStateOnServer(_ref) {
  var baseTag = _ref.baseTag,
      bodyAttributes = _ref.bodyAttributes,
      encode = _ref.encode,
      htmlAttributes = _ref.htmlAttributes,
      linkTags = _ref.linkTags,
      metaTags = _ref.metaTags,
      noscriptTags = _ref.noscriptTags,
      scriptTags = _ref.scriptTags,
      styleTags = _ref.styleTags,
      _ref$title = _ref.title,
      title = _ref$title === undefined ? '' : _ref$title,
      titleAttributes = _ref.titleAttributes;
  return {
    base: getMethodsForTag(_constants.TAG_NAMES.BASE, baseTag, encode),
    bodyAttributes: getMethodsForTag(_constants.ATTRIBUTE_NAMES.BODY, bodyAttributes, encode),
    htmlAttributes: getMethodsForTag(_constants.ATTRIBUTE_NAMES.HTML, htmlAttributes, encode),
    link: getMethodsForTag(_constants.TAG_NAMES.LINK, linkTags, encode),
    meta: getMethodsForTag(_constants.TAG_NAMES.META, metaTags, encode),
    noscript: getMethodsForTag(_constants.TAG_NAMES.NOSCRIPT, noscriptTags, encode),
    script: getMethodsForTag(_constants.TAG_NAMES.SCRIPT, scriptTags, encode),
    style: getMethodsForTag(_constants.TAG_NAMES.STYLE, styleTags, encode),
    title: getMethodsForTag(_constants.TAG_NAMES.TITLE, { title: title, titleAttributes: titleAttributes }, encode)
  };
};

exports.default = mapStateOnServer;