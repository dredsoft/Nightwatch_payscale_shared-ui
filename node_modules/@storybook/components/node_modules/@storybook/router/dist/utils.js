"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var qs_1 = __importDefault(require("qs"));
var memoizerific_1 = __importDefault(require("memoizerific"));
var knownViewModesRegex = /(story|info)/;
var splitPath = /\/([^/]+)\/([^/]+)?/;
// Remove punctuation https://gist.github.com/davidjrice/9d2af51100e41c6c4b4a
exports.sanitize = function (string) {
    return string
        .toLowerCase()
        .replace(/[ ’–—―′¿'`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/gi, '-')
        .replace(/-+/g, '-')
        .replace(/^-+/, '')
        .replace(/-+$/, '');
};
var sanitizeSafe = function (string, part) {
    var sanitized = exports.sanitize(string);
    if (sanitized === '') {
        throw new Error("Invalid " + part + " '" + string + "', must include alphanumeric characters");
    }
    return sanitized;
};
exports.toId = function (kind, name) { return sanitizeSafe(kind, 'kind') + "--" + sanitizeSafe(name, 'name'); };
exports.storyDataFromString = memoizerific_1.default(1000)(function (path) {
    var result = {
        viewMode: undefined,
        storyId: undefined,
    };
    if (path) {
        var _a = path.match(splitPath) || [undefined, undefined, undefined], viewMode = _a[1], storyId = _a[2];
        if (viewMode && viewMode.match(knownViewModesRegex)) {
            Object.assign(result, {
                viewMode: viewMode,
                storyId: storyId,
            });
        }
    }
    return result;
});
exports.queryFromString = memoizerific_1.default(1000)(function (s) { return qs_1.default.parse(s, { ignoreQueryPrefix: true }); });
exports.queryFromLocation = function (location) { return exports.queryFromString(location.search); };
exports.stringifyQuery = function (query) { return qs_1.default.stringify(query, { addQueryPrefix: true, encode: false }); };
exports.getMatch = memoizerific_1.default(1000)(function (current, target, startsWith) {
    if (startsWith === void 0) { startsWith = true; }
    var startsWithTarget = current && startsWith && current.startsWith(target);
    var currentIsTarget = typeof target === 'string' && current === target;
    var matchTarget = current && target && current.match(target);
    if (startsWithTarget || currentIsTarget || matchTarget) {
        return { path: current };
    }
    return null;
});
